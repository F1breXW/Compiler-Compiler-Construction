# 演示备忘单（快速参考）

## 🎯 核心演示要点

### ⭐ 必须强调的关键点

#### 1. 自动生成（A要求）
**两个完全不同的文法**：
- 文法1：8词法规则 → 9 DFA状态 → 18 LALR状态
- 文法2：5词法规则 → 7 DFA状态 → 12 LALR状态
- **证明**：系统自动识别文法差异并生成不同的分析器

#### 2. 正确性测试（B要求）⭐ 关键改进
**正确性测试 = 正例测试 + 负例测试**：
- ✅ **正例**：文法1 × 2个合法程序、文法2 × 2个合法程序 = 全部正确接受
- ✅ **负例**：文法1 × 1个错误程序 = 正确拒绝
- **证明**：不仅能识别正确的，还能识别错误的 → 真正理解文法

---

## 📋 演示命令清单

### ⭐ 推荐：使用分步骤脚本（清晰展示两个阶段）

```bash
# 文法1 - 算术表达式（强调：8规则、9 DFA、18 LALR）
python demo_two_stages.py configs/grammar1_arithmetic.json test_programs/arithmetic_1.txt
python demo_two_stages.py configs/grammar1_arithmetic.json test_programs/arithmetic_2.txt

# 文法2 - 赋值语句（强调：5规则、7 DFA、12 LALR，完全不同！）
python demo_two_stages.py configs/grammar2_assignment.json test_programs/assignment_1.txt
python demo_two_stages.py configs/grammar2_assignment.json test_programs/assignment_2.txt

# ⭐ 错误检测（证明正确性）
python demo_two_stages.py configs/grammar1_arithmetic.json test_programs/arithmetic_error1.txt
# 源程序: id + * id（连续运算符）
# 预期: ❌ 非法语句（语法错误）→ 证明能识别错误！
```

**优势**：
- ✅ **阶段1**：输入文法 → 显示自动生成的编译器（规则数、状态数）
- ✅ **中间暂停**：按回车键继续，方便讲解
- ✅ **阶段2**：输入源程序 → 显示分析结果（合法性、产生式、语法树）
- ✅ **符合要求**：两个阶段完全分离，一目了然

---

### 备用：一步完成

### 第一部分

```bash
# 文法1 - 算术表达式（强调：8规则、9状态、18 LALR）
python test_from_file.py configs/grammar1_arithmetic.json test_programs/arithmetic_1.txt
python test_from_file.py configs/grammar1_arithmetic.json test_programs/arithmetic_2.txt

# 文法2 - 赋值语句（强调：5规则、7状态、12 LALR，完全不同！）
python test_from_file.py configs/grammar2_assignment.json test_programs/assignment_1.txt
python test_from_file.py configs/grammar2_assignment.json test_programs/assignment_2.txt
```

### 第二部分

```bash
# 基础：算术运算
python tests/intermediate_code/test_ic_generation.py test_programs/intermediate_code/ic_test1_arithmetic.txt


```

---

## 💬 讲解话术（逐字稿）

### 开场（30秒）
> "各位老师好，我们的项目是编译器生成器，能根据不同的文法自动生成编译器。演示分两部分：第一部分测试2个不同文法的自动生成，第二部分展示中间代码生成。"

### 文法1讲解（阶段1完成后）
> "可以看到，**阶段1：输入文法规则**。系统自动构建了8个词法规则的DFA，有9个状态。然后自动生成了18个LALR状态的分析表。这个过程完全自动化，包括Thompson构造、子集构造、DFA最小化和LALR构建。"

**【按回车键，进入阶段2】**

> "现在**阶段2：输入源程序**。词法分析生成Token序列，语法分析判断合法性，输出产生式序列和语法树。"

### 文法2讲解（阶段1完成后，⭐ 关键）
> "现在切换到第二个文法——赋值语句文法。注意观察**阶段1的输出**，这是**完全不同的文法**：
> - 词法规则从**8个变为5个**
> - DFA状态从**9个变为7个**
> - LALR状态从**18个变为12个**
> 
> 系统**自动识别**了文法的差异，并**重新生成**了完全不同的分析器。这证明了我们的自动生成能力，不是手写的分析表！"

**【按回车键，进入阶段2】**

> "阶段2测试源程序，输出合法性判断、产生式序列和语法树。"

### 中间代码讲解（if/else后）
> "这里展示了回填技术。可以看到系统生成了L1、L2等标签，并使用条件跳转指令if_false和goto。回填技术是在生成跳转指令时先留空目标地址，等确定标签位置后再回填。"

### 总结（30秒）
> "以上演示了2个不同文法的自动生成，包括4个正确程序和1个错误程序的测试。正确程序全部通过，错误程序正确拒绝，验证了分析器的正确性。第二部分演示了中间代码生成。项目实现了从文法规则到中间代码的完整编译器前端。谢谢老师！"

---

## 📊 对比数据（快速查看）

| 项目 | 文法1 | 文法2 | 差异 |
|------|-------|-------|------|
| 词法规则 | 8 | 5 | **不同** |
| DFA状态 | 9 | 7 | **不同** |
| LALR状态 | 18 | 12 | **不同** |
| 正确程序 | 2个 ✅ | 2个 ✅ | 都正确 |
| 错误程序 | 1个 ❌ | - | 正确拒绝 |

**结论**：自动生成 ✅，正确性（正例+负例）✅

---

## 🚨 常见问题快速应对

### Q: 你们是自动生成还是手写的？
**A**: "完全自动生成。您可以看到两个文法生成的分析器完全不同：DFA状态数和LALR状态数都不一样。如果是手写的，不可能针对每个文法手写不同的分析表。"

### Q: 怎么证明是不同的文法？
**A**: "文法1是算术表达式，支持括号和乘除优先级；文法2是赋值语句，有':='符号。生成的分析器规模也完全不同：18个LALR状态 vs 12个LALR状态。"

### Q3: 为什么要测试错误程序？
**A**: "正确性测试不仅要验证能接受合法程序，还要验证能拒绝非法程序。比如'id + * id'这样的错误程序，分析器能正确识别出语法错误，说明真正理解了文法规则。"

### Q4: 为什么选择LALR而不是LL？
**A**: "LALR(1)能处理左递归文法，比LL(1)功能更强。我们的实现包括完整的LR(1)项目集构建和LALR压缩优化。"

### Q: 中间代码的回填技术是什么？
**A**: "在生成条件跳转时，目标标签还不确定，所以先留空。等到确定标签位置后，再回填跳转地址。这样可以单趟完成中间代码生成。"

---

## ⏱️ 时间分配

| 阶段 | 时间 | 内容 |
|------|------|------|
| 开场 | 1分钟 | 项目介绍 |
| 文法1测试1 | 3分钟 | 运行+讲解自动生成 |
| 文法1测试2 | 2分钟 | 运行+展示正确性 |
| 文法2测试1 | 4分钟 | **运行+强调文法差异** |
| 文法2测试2 | 2分钟 | 验证正确性 |
| **错误测试** | **2分钟** | **运行错误程序+讲解识别能力** |
| 对比总结 | 2分钟 | 展示对比表格 |
| IC基础测试 | 3分钟 | 算术运算 |
| IC控制流 | 4分钟 | if/else + 回填讲解 |
| IC循环 | 3分钟 | while循环 |
| 总结 | 1分钟 | 总结陈述 |
| **总计** | **27分钟** | 预留3分钟Q&A |

---

## ✅ 演示前检查清单

- [ ] 终端字体放大（确保观众能看清）
- [ ] 测试所有命令能运行
- [ ] 清空generated/目录
- [ ] 准备计时器
- [ ] 打开configs文件（方便展示）
- [ ] 准备备用方案（录屏视频）
- [ ] 熟记两个文法的差异数据（8→5，9→7，18→12）

---

## 🎯 关键成功因素

1. **反复强调"不同文法"**：至少说3次
2. **展示具体数据差异**：8→5，9→7，18→12
3. **对比演示**：文法1和文法2形成鲜明对比
4. **强调自动化**：没有手写任何分析表
5. **展示错误检测**：不仅接受正确的，还能拒绝错误的
6. **控制节奏**：不要太快也不要太慢
7. **自信表达**：熟悉所有技术细节

---

**祝演示成功！记住：重点是证明"自动生成不同的分析器"+"正确识别正例和负例"！** 🎉
